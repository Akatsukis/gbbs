(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{110:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return p})),a.d(t,"toc",(function(){return c})),a.d(t,"default",(function(){return m}));var n=a(3),r=a(7),s=(a(0),a(120)),i={id:"kcore_tutorial",title:"KCore Tutorial"},p={unversionedId:"tutorial/kcore_tutorial",id:"tutorial/kcore_tutorial",isDocsHomePage:!1,title:"KCore Tutorial",description:"WIP",source:"@site/docs/tutorial/kcore_tutorial.md",slug:"/tutorial/kcore_tutorial",permalink:"/gbbs/docs/tutorial/kcore_tutorial",version:"current"},c=[{value:"Getting Started",id:"getting-started",children:[]},{value:"Representing a Frontier",id:"representing-a-frontier",children:[]},{value:"Traversing a Frontier",id:"traversing-a-frontier",children:[]},{value:"Implementing Traversal Logic",id:"implementing-traversal-logic",children:[]},{value:"The Final Algorithm",id:"the-final-algorithm",children:[]},{value:"Wrapping up: BFS.cc and Build-files.",id:"wrapping-up-bfscc-and-build-files",children:[]},{value:"Compilation",id:"compilation",children:[]},{value:"Testing",id:"testing",children:[]}],l={toc:c};function m(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(s.b)("wrapper",Object(n.a)({},l,a,{components:t,mdxType:"MDXLayout"}),Object(s.b)("p",null,"WIP"),Object(s.b)("p",null,"In this tutorial we'll implement a parallel version of Breadth-First Search in\nGBBS. Given a graph, ",Object(s.b)("span",{parentName:"p",className:"math math-inline"},Object(s.b)("span",{parentName:"span",className:"katex"},Object(s.b)("span",{parentName:"span",className:"katex-mathml"},Object(s.b)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},Object(s.b)("semantics",{parentName:"math"},Object(s.b)("mrow",{parentName:"semantics"},Object(s.b)("mi",{parentName:"mrow"},"G"),Object(s.b)("mo",{parentName:"mrow"},"="),Object(s.b)("mo",{parentName:"mrow",stretchy:"false"},"("),Object(s.b)("mi",{parentName:"mrow"},"V"),Object(s.b)("mo",{parentName:"mrow",separator:"true"},","),Object(s.b)("mi",{parentName:"mrow"},"E"),Object(s.b)("mo",{parentName:"mrow",stretchy:"false"},")")),Object(s.b)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"G = (V,E)")))),Object(s.b)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},Object(s.b)("span",{parentName:"span",className:"base"},Object(s.b)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),Object(s.b)("span",{parentName:"span",className:"mord mathdefault"},"G"),Object(s.b)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),Object(s.b)("span",{parentName:"span",className:"mrel"},"="),Object(s.b)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),Object(s.b)("span",{parentName:"span",className:"base"},Object(s.b)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),Object(s.b)("span",{parentName:"span",className:"mopen"},"("),Object(s.b)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.22222em"}},"V"),Object(s.b)("span",{parentName:"span",className:"mpunct"},","),Object(s.b)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),Object(s.b)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.05764em"}},"E"),Object(s.b)("span",{parentName:"span",className:"mclose"},")"))))),", and a source node ",Object(s.b)("span",{parentName:"p",className:"math math-inline"},Object(s.b)("span",{parentName:"span",className:"katex"},Object(s.b)("span",{parentName:"span",className:"katex-mathml"},Object(s.b)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},Object(s.b)("semantics",{parentName:"math"},Object(s.b)("mrow",{parentName:"semantics"},Object(s.b)("mi",{parentName:"mrow"},"s")),Object(s.b)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"s")))),Object(s.b)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},Object(s.b)("span",{parentName:"span",className:"base"},Object(s.b)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),Object(s.b)("span",{parentName:"span",className:"mord mathdefault"},"s"))))),", a Breadth-First Search\nprocesses the graph level by level, starting from ",Object(s.b)("span",{parentName:"p",className:"math math-inline"},Object(s.b)("span",{parentName:"span",className:"katex"},Object(s.b)("span",{parentName:"span",className:"katex-mathml"},Object(s.b)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},Object(s.b)("semantics",{parentName:"math"},Object(s.b)("mrow",{parentName:"semantics"},Object(s.b)("mi",{parentName:"mrow"},"s")),Object(s.b)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"s")))),Object(s.b)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},Object(s.b)("span",{parentName:"span",className:"base"},Object(s.b)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),Object(s.b)("span",{parentName:"span",className:"mord mathdefault"},"s"))))),". The output of the\nalgorithm is an array ",Object(s.b)("span",{parentName:"p",className:"math math-inline"},Object(s.b)("span",{parentName:"span",className:"katex"},Object(s.b)("span",{parentName:"span",className:"katex-mathml"},Object(s.b)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},Object(s.b)("semantics",{parentName:"math"},Object(s.b)("mrow",{parentName:"semantics"},Object(s.b)("mi",{parentName:"mrow"},"A")),Object(s.b)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"A")))),Object(s.b)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},Object(s.b)("span",{parentName:"span",className:"base"},Object(s.b)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),Object(s.b)("span",{parentName:"span",className:"mord mathdefault"},"A")))))," s.t. ",Object(s.b)("span",{parentName:"p",className:"math math-inline"},Object(s.b)("span",{parentName:"span",className:"katex"},Object(s.b)("span",{parentName:"span",className:"katex-mathml"},Object(s.b)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},Object(s.b)("semantics",{parentName:"math"},Object(s.b)("mrow",{parentName:"semantics"},Object(s.b)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2200"),Object(s.b)("mi",{parentName:"mrow"},"v"),Object(s.b)("mo",{parentName:"mrow"},"\u2208"),Object(s.b)("mi",{parentName:"mrow"},"V"),Object(s.b)("mo",{parentName:"mrow",separator:"true"},","),Object(s.b)("mi",{parentName:"mrow"},"A"),Object(s.b)("mo",{parentName:"mrow",stretchy:"false"},"["),Object(s.b)("mi",{parentName:"mrow"},"v"),Object(s.b)("mo",{parentName:"mrow",stretchy:"false"},"]")),Object(s.b)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\forall v \\in V, A[v]")))),Object(s.b)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},Object(s.b)("span",{parentName:"span",className:"base"},Object(s.b)("span",{parentName:"span",className:"strut",style:{height:"0.73354em",verticalAlign:"-0.0391em"}}),Object(s.b)("span",{parentName:"span",className:"mord"},"\u2200"),Object(s.b)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.03588em"}},"v"),Object(s.b)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),Object(s.b)("span",{parentName:"span",className:"mrel"},"\u2208"),Object(s.b)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),Object(s.b)("span",{parentName:"span",className:"base"},Object(s.b)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),Object(s.b)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.22222em"}},"V"),Object(s.b)("span",{parentName:"span",className:"mpunct"},","),Object(s.b)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),Object(s.b)("span",{parentName:"span",className:"mord mathdefault"},"A"),Object(s.b)("span",{parentName:"span",className:"mopen"},"["),Object(s.b)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.03588em"}},"v"),Object(s.b)("span",{parentName:"span",className:"mclose"},"]")))))," holds the parent of ",Object(s.b)("span",{parentName:"p",className:"math math-inline"},Object(s.b)("span",{parentName:"span",className:"katex"},Object(s.b)("span",{parentName:"span",className:"katex-mathml"},Object(s.b)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},Object(s.b)("semantics",{parentName:"math"},Object(s.b)("mrow",{parentName:"semantics"},Object(s.b)("mi",{parentName:"mrow"},"v")),Object(s.b)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"v")))),Object(s.b)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},Object(s.b)("span",{parentName:"span",className:"base"},Object(s.b)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),Object(s.b)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.03588em"}},"v")))))," in\nthe ",Object(s.b)("em",{parentName:"p"},"breadth-first tree")," rooted at ",Object(s.b)("span",{parentName:"p",className:"math math-inline"},Object(s.b)("span",{parentName:"span",className:"katex"},Object(s.b)("span",{parentName:"span",className:"katex-mathml"},Object(s.b)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},Object(s.b)("semantics",{parentName:"math"},Object(s.b)("mrow",{parentName:"semantics"},Object(s.b)("mi",{parentName:"mrow"},"s")),Object(s.b)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"s")))),Object(s.b)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},Object(s.b)("span",{parentName:"span",className:"base"},Object(s.b)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),Object(s.b)("span",{parentName:"span",className:"mord mathdefault"},"s"))))),"."),Object(s.b)("h3",{id:"getting-started"},"Getting Started"),Object(s.b)("p",null,"In what follows we will reimplement the BFS algorithm shown in the\nfile above and go through all of the steps to create a new benchmark\nin GBBS."),Object(s.b)("p",null,"To get started, cd into the ",Object(s.b)("inlineCode",{parentName:"p"},"benchmarks/BFS")," directory and create a\nnew directory ",Object(s.b)("inlineCode",{parentName:"p"},"BFS_tutorial"),". Create two new files in this directory,\n",Object(s.b)("inlineCode",{parentName:"p"},"BFS.cc")," and ",Object(s.b)("inlineCode",{parentName:"p"},"BFS.h"),".\nWe will start with the interesting algorithmic code in ",Object(s.b)("inlineCode",{parentName:"p"},"BFS.h"),"."),Object(s.b)("p",null,"Let's start by creating a stub for the BFS function:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-cpp"},"template <class Graph>\ninline sequence<uintE> BFS(Graph& G, uintE source) {\n\n}\n")),Object(s.b)("p",null,"One of the goals of GBBS is to abstract away implementation specific\ndetails about how the graph is represented. Towards this goal, the\nalgorithm implementations in GBBS typically take the graph type as a\ntemplate argument, as shown above. This approach lets us run the same\ncode on the graph whether it is compressed or uncompressed, and\ndirected or undirected."),Object(s.b)("p",null,"The ",Object(s.b)("inlineCode",{parentName:"p"},"uintE")," type name is an integer type used to represent vertex-ids\nin GBBS (the analogous type for edge-ids is ",Object(s.b)("inlineCode",{parentName:"p"},"uintT")," although we won't\nuse it in this implementation)."),Object(s.b)("p",null,"The BFS function's signature indicates that it takes as input a graph,\nand a source vertex-id and returns a sequence of integers representing\nthe parent of each vertex in the BFS tree."),Object(s.b)("p",null,"Next, modify the BFS implementation to the following:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-cpp"},"template <class Graph>\ninline sequence<uintE> BFS(Graph& G, uintE source) {\n  using W = typename Graph::weight_type;\n  uintE n = G.n;\n\n  // Creates Parents array, initialized to all -1, except for source.\n  auto Parents = sequence<uintE>(n, [&](size_t i) { return UINT_E_MAX; });\n  Parents[source] = source;\n\n}\n")),Object(s.b)("p",null,"Here, we set ",Object(s.b)("inlineCode",{parentName:"p"},"W")," to the weight-type in the provided graph. For\nunweighted graphs, this is the type of an empty struct (with no data),\nand otherwise it is the graph's weight type, e.g., ",Object(s.b)("inlineCode",{parentName:"p"},"int32")," or ",Object(s.b)("inlineCode",{parentName:"p"},"float"),"."),Object(s.b)("p",null,"Next, we set the ",Object(s.b)("inlineCode",{parentName:"p"},"Parents")," array to a sequence containing ",Object(s.b)("span",{parentName:"p",className:"math math-inline"},Object(s.b)("span",{parentName:"span",className:"katex"},Object(s.b)("span",{parentName:"span",className:"katex-mathml"},Object(s.b)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},Object(s.b)("semantics",{parentName:"math"},Object(s.b)("mrow",{parentName:"semantics"},Object(s.b)("mi",{parentName:"mrow"},"n")),Object(s.b)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),Object(s.b)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},Object(s.b)("span",{parentName:"span",className:"base"},Object(s.b)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),Object(s.b)("span",{parentName:"span",className:"mord mathdefault"},"n")))))," (",Object(s.b)("inlineCode",{parentName:"p"},"G.n"),")\nelements where the i'th element is some suitable null value, in this\ncase the maximum unsigned ",Object(s.b)("inlineCode",{parentName:"p"},"uintE"),", ",Object(s.b)("inlineCode",{parentName:"p"},"UINT_E_MAX"),". Note that the\ninitialization of this sequence will happen in parallel when we use a\nparallel runtime.\nWe also set the parent of the source vertex to itself."),Object(s.b)("p",null,"So far, we have set up the variables and data necessary for the\nalgorithm, and we're ready to start the interesting parts of the BFS."),Object(s.b)("h3",{id:"representing-a-frontier"},"Representing a Frontier"),Object(s.b)("p",null,"We can express a frontier generated by the BFS with the ",Object(s.b)("strong",{parentName:"p"},Object(s.b)("inlineCode",{parentName:"strong"},"vertexSubset")),"\ndatatype (from the Ligra interface), which lets us represent a subset\nof the vertices. Each level of the  traversal will be represented by a\n",Object(s.b)("inlineCode",{parentName:"p"},"vertexSubset"),". The initial ",Object(s.b)("inlineCode",{parentName:"p"},"vertexSubset"),", is just a set containing\nour source node can be constructed the following constructor"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-cpp"},"template <class W>\nstruct BFS_F {\n  uintE* Parents;\n  BFS_F(uintE* _Parents) : Parents(_Parents) { }\n  inline bool updateAtomic (uintE s, uintE d, W w) { // Atomically update.\n    return pbbslib::atomic_compare_and_swap(&Parents[d], UINT_E_MAX, s);\n  }\n  inline bool update (uintE s, uintE d, W w) { // Defer to updateAtomic for now.\n    return updateAtomic(s, d, w);\n  }\n  // Cond function checks if vertex has been visited yet.\n  inline bool cond (uintE d) { return (Parents[d] == UINT_E_MAX); }\n};\nvertexSubset Frontier(n, source); // creates initial frontier\n")),Object(s.b)("h3",{id:"traversing-a-frontier"},"Traversing a Frontier"),Object(s.b)("p",null,"Now, we need to describe the logic to produce the next frontier given the current\nfrontier. Enter ",Object(s.b)("strong",{parentName:"p"},Object(s.b)("inlineCode",{parentName:"strong"},"edgeMap")),". ",Object(s.b)("inlineCode",{parentName:"p"},"edgeMap")," (from the Ligra interface)\nallows us to process the out edges of a ",Object(s.b)("inlineCode",{parentName:"p"},"vertexSubset"),", and produce a\nnew ",Object(s.b)("inlineCode",{parentName:"p"},"vertexSubset"),"."),Object(s.b)("p",null,"The behavior of ",Object(s.b)("inlineCode",{parentName:"p"},"edgeMap")," is intended to be customized by providing a\nuser-defined structure. ",Object(s.b)("inlineCode",{parentName:"p"},"edgeMap")," expects a parameter of some template\nclass ",Object(s.b)("inlineCode",{parentName:"p"},"F")," that has the following fields:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-cpp"},"template <class W>\nstruct F {\n  F(...) { ... }\n  inline bool update (uintE u, uintE v, W wgh) {\n    // logic for how to process the edge (s,d)\n  }\n\n  inline bool updateAtomic (uintE u, uintE v, W wgh) {\n    // logic for how to process the edge (s,d)\n  }\n\n  inline bool cond (uintE d) {\n    // return 1 if update should be applied on and edge (s,d)\n    // return 0 otherwise\n  }\n};\n")),Object(s.b)("p",null,"There is an important distinction between ",Object(s.b)("inlineCode",{parentName:"p"},"update")," and ",Object(s.b)("inlineCode",{parentName:"p"},"updateAtomic"),"\nthat we will discuss later. For now, we will make sure that all\n",Object(s.b)("inlineCode",{parentName:"p"},"update")," logic is atomic.  Atomicity is important because if the\nvertex has more than one in-edge from the current frontier, then\nmultiple calls to ",Object(s.b)("inlineCode",{parentName:"p"},"update")," can happen in parallel which may result in\nan incorrect result."),Object(s.b)("p",null,"For our BFS, let's implement a struct ",Object(s.b)("inlineCode",{parentName:"p"},"BFS_F")," where"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("p",{parentName:"li"},Object(s.b)("inlineCode",{parentName:"p"},"updateAtomic"),": atomically update ",Object(s.b)("inlineCode",{parentName:"p"},"Parents")," array. We can implement this using a\ncompare and swap operation, which is provided in the ",Object(s.b)("inlineCode",{parentName:"p"},"pbbslib"),"\nlibrary as ",Object(s.b)("inlineCode",{parentName:"p"},"pbbslib::atomic_compare_and_swap"),".")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("p",{parentName:"li"},Object(s.b)("inlineCode",{parentName:"p"},"cond"),": avoid revisiting previously visited vertices by checking if\n",Object(s.b)("inlineCode",{parentName:"p"},"Parents[v] == UINT_E_MAX"),"."))),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-cpp"},"template <class W>\nstruct BFS_F {\n  uintE* Parents;\n  BFS_F(uintE* _Parents) : Parents(_Parents) { }\n  inline bool updateAtomic (uintE s, uintE d, W w) { // Atomically update.\n    return pbbslib::atomic_compare_and_swap(&Parents[d], UINT_E_MAX, s);\n  }\n  inline bool update (uintE s, uintE d, W w) { // Defer to updateAtomic for now.\n    return updateAtomic(s, d, w);\n  }\n  // Cond function checks if vertex has been visited yet.\n  inline bool cond (uintE d) { return (Parents[d] == UINT_E_MAX); }\n};\n")),Object(s.b)("p",null,"Add this code before the definition of ",Object(s.b)("inlineCode",{parentName:"p"},"BFS"),"."),Object(s.b)("p",null,"Notice that while ",Object(s.b)("inlineCode",{parentName:"p"},"BFS_F")," will correctly produce the next frontier, the\ntree computed by the BFS is still non-deterministic! We will discuss how to\nfix this in a later section."),Object(s.b)("h3",{id:"implementing-traversal-logic"},"Implementing Traversal Logic"),Object(s.b)("p",null,"All we need to do to finish up the BFS is to actually call ",Object(s.b)("inlineCode",{parentName:"p"},"edgeMap"),", and\nadd a termination condition that signifies when the traversal is finished.\nGiven a current frontier, our condition should just apply the edgeMap while\nthe current frontier is non-empty. In code:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-cpp"},"while (!Frontier.isEmpty()) { // Loop until frontier is empty.\n  vertexSubset output = edgeMap(GA, Frontier, BFS_F(Parents.begin()));\n  Frontier.del();\n  Frontier = output; //set new frontier\n}\n")),Object(s.b)("h3",{id:"the-final-algorithm"},"The Final Algorithm"),Object(s.b)("p",null,"The last step is to just free any memory allocated in the body of the BFS.\nOur finished BFS algorithm should look as follows:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n\n#include "gbbs/gbbs.h"\n\nnamespace gbbs {\n\ntemplate <class W>\nstruct BFS_F {\n  uintE* Parents;\n  BFS_F(uintE* _Parents) : Parents(_Parents) { }\n  inline bool updateAtomic (uintE s, uintE d, W w) { // Atomically update.\n    return pbbslib::atomic_compare_and_swap(&Parents[d], UINT_E_MAX, s);\n  }\n  inline bool update (uintE s, uintE d, W w) { // Defer to updateAtomic for now.\n    return updateAtomic(s, d, w);\n  }\n  // Cond function checks if vertex has been visited yet.\n  inline bool cond (uintE d) { return (Parents[d] == UINT_E_MAX); }\n};\n\ntemplate <class Graph>\ninline sequence<uintE> BFS(Graph& G, uintE source) {\n  using W = typename Graph::weight_type;\n  uintE n = G.n;\n\n  // Creates Parents array, initialized to all -1, except for source.\n  auto Parents = sequence<uintE>(n, [&](size_t i) { return UINT_E_MAX; });\n  Parents[source] = source;\n\n  vertexSubset Frontier(n, source);\n  size_t reachable = 0;\n  while (!Frontier.isEmpty()) {\n    std::cout << Frontier.size() << std::endl;\n    reachable += Frontier.size();\n    vertexSubset output = edgeMap(G, Frontier, BFS_F<W>(Parents.begin()));\n    Frontier.del();\n    Frontier = output;\n  }\n  Frontier.del();\n  std::cout << "Reachable: " << reachable << std::endl;\n  return Parents;\n}\n\n}  // namespace gbbs\n')),Object(s.b)("p",null,"At this point we have created a BFS implementation"),Object(s.b)("h3",{id:"wrapping-up-bfscc-and-build-files"},"Wrapping up: BFS.cc and Build-files."),Object(s.b)("p",null,"Lastly, let's see what code we need to add in order to create a binary to\nrun BFS on graph inputs. Place the following code in ",Object(s.b)("inlineCode",{parentName:"p"},"BFS.cc"),"."),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-cpp"},'#include "BFS.h"\n\nnamespace gbbs {\n\ntemplate <class Graph>\ndouble BFS_runner(Graph& G, commandLine P) {\n  uintE src = static_cast<uintE>(P.getOptionLongValue("-src", 0));\n\n  std::cout << "### Application: BFS" << std::endl;\n  std::cout << "### Graph: " << P.getArgument(0) << std::endl;\n  std::cout << "### Threads: " << num_workers() << std::endl;\n  std::cout << "### n: " << G.n << std::endl;\n  std::cout << "### m: " << G.m << std::endl;\n  std::cout << "### Params: -src = " << src << std::endl;\n  std::cout << "### ------------------------------------" << std::endl;\n  std::cout << "### ------------------------------------" << std::endl;\n\n  timer t; t.start();\n  auto parents = BFS(G, src);\n  double tt = t.stop();\n\n  std::cout << "### Running Time: " << tt << std::endl;\n  return tt;\n}\n\n}  // namespace gbbs\n\ngenerate_main(gbbs::BFS_runner, false);\n')),Object(s.b)("p",null,"The main points of interest in this code are the ",Object(s.b)("inlineCode",{parentName:"p"},"generate_main")," function,\nwhich is a macro defined by GBBS (see ",Object(s.b)("inlineCode",{parentName:"p"},"gbbs/benchmark.h"),") that first loads\nthe graph supplied as input by the user, and calls ",Object(s.b)("inlineCode",{parentName:"p"},"gbbs::BFS_runner"),". The\n",Object(s.b)("inlineCode",{parentName:"p"},"false")," flag passed to this macro indicates that this application does not\nmodify the input graph. The macro expects a runner function that takes as\ninput a graph and a ",Object(s.b)("inlineCode",{parentName:"p"},"commandLine")," object which supplies the command-line\narguments provided by the user."),Object(s.b)("p",null,"Lastly, if you are using Bazel add a file called ",Object(s.b)("inlineCode",{parentName:"p"},"BUILD")," with the following\ncontents to this directory:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-cpp"},'cc_library(\n  name = "BFS",\n  hdrs = ["BFS.h"],\n  deps = ["//gbbs:gbbs"]\n)\n\ncc_binary(\n  name = "BFS_main",\n  srcs = ["BFS.cc"],\n  deps = [":BFS"]\n)\n\npackage(\n  default_visibility = ["//visibility:public"],\n)\n')),Object(s.b)("p",null,"This BUILD file contains two build rules, which tells Bazel how to build\nthe desired outputs, such as executable binaries (",Object(s.b)("inlineCode",{parentName:"p"},"cc_binary"),") and\nlibraries (",Object(s.b)("inlineCode",{parentName:"p"},"cc_library"),"). Build rules are also called targets, and point to\na specific set of source files and dependencies. A target can also point to\nother targets, as seen in the dependencies for ",Object(s.b)("inlineCode",{parentName:"p"},"cc_binary"),"."),Object(s.b)("p",null,"You can read more about Bazel\n",Object(s.b)("a",{parentName:"p",href:"https://docs.bazel.build/versions/master/tutorial/cpp.html"},"here"),"."),Object(s.b)("h3",{id:"compilation"},"Compilation"),Object(s.b)("p",null,"Using Bazel you can compile the application the BFS application as follows:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-sh"},"$ bazel build //benchmarks/BFS/BFS_tutorial/...\n")),Object(s.b)("p",null,"To use ",Object(s.b)("inlineCode",{parentName:"p"},"make")," you can copy the makefile from\n",Object(s.b)("inlineCode",{parentName:"p"},"benchmarks/BFS/NondeterministicBFS/makefile"),", and run ",Object(s.b)("inlineCode",{parentName:"p"},"make"),"."),Object(s.b)("h3",{id:"testing"},"Testing"),Object(s.b)("p",null,"Let's try running our program on one of the test-inputs provided by Ligra in the ",Object(s.b)("inlineCode",{parentName:"p"},"inputs/"),"\ndirectory."),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-sh"},"$ numactl -i all ./bazel-bin/benchmarks/BFS/NonDeterministicBFS/BFS_main \\\n    -s -rounds 4 -src 0 inputs/rMatGraph_J_5_100\n# list_alloc init_blocks: 1000\n# after init:\n# Used: 0, allocated: 79872, node size: 16392, bytes: 1309261824\n### Application: BFS\n### Graph: inputs/rMatGraph_J_5_100\n### Threads: 144\n### n: 128\n### m: 708\n### Params: -src = 0\n### ------------------------------------\n### ------------------------------------\n1\n8\n20\n50\n41\n5\nReachable: 125\n### Running Time: 0.000113964\n...\n")),Object(s.b)("p",null,"The flags above indicate the following:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"The ",Object(s.b)("inlineCode",{parentName:"li"},"-s")," flag indicates that the graph is symmetric."),Object(s.b)("li",{parentName:"ul"},"The ",Object(s.b)("inlineCode",{parentName:"li"},"-rounds")," flag indicates the number of times to run the benchmark."),Object(s.b)("li",{parentName:"ul"},"The ",Object(s.b)("inlineCode",{parentName:"li"},"-src")," flag indicates the source vertex.")),Object(s.b)("p",null,"Great! We've successfully implemented a shared memory breadth-first\nsearch in GBBS. You should now have all of the pieces needed to\nimplement new benchmarks in GBBS."))}m.isMDXComponent=!0},120:function(e,t,a){"use strict";a.d(t,"a",(function(){return o})),a.d(t,"b",(function(){return d}));var n=a(0),r=a.n(n);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function p(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=r.a.createContext({}),m=function(e){var t=r.a.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):p(p({},t),e)),a},o=function(e){var t=m(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),o=m(a),u=n,d=o["".concat(i,".").concat(u)]||o[u]||b[u]||s;return a?r.a.createElement(d,p(p({ref:t},l),{},{components:a})):r.a.createElement(d,p({ref:t},l))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,i=new Array(s);i[0]=u;var p={};for(var c in t)hasOwnProperty.call(t,c)&&(p[c]=t[c]);p.originalType=e,p.mdxType="string"==typeof e?e:n,i[1]=p;for(var l=2;l<s;l++)i[l]=a[l];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);